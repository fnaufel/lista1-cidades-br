---
title: 'Cidades brasileiras: respostas'
subtitle: 'Lista avaliativa -- Probabilidade e Estatística -- 2022.1'
author: 'fnaufel'
email: 'https://fnaufel.github.io/'
date: '(v. `r format(Sys.Date(), "%d/%m/%Y")`)'
lang: 'pt-br'

output: 
  # To install these output formats, run
  #   install.packages("devtools")
  #   devtools::install_github("fnaufel/fnaufelRmd")
  fnaufelRmd::html_report:
    []
    # css:
    #   - default
    #   - html_files/webex.css
    # includes:
    #   after_body: 
    #   - html_files/webex.js

---

```{r setup, include=FALSE}
# The next command configures MANY things and loads quite a few packages.
# 
# If you want to see what's being done, execute 
# 
#   cat(
#     system.file(
#       "rmarkdown/resources/R/_common_report.R", 
#       package = "fnaufelRmd"
#     )
#   )
# 
# to find out the location of the file. Then open the file.
# 
# If you want to change the configuration, copy the file, edit it, and
# source it instead of the package file. 
# 
# Or simply write your commands here in this code chunk.

source(
  system.file(
    "rmarkdown/resources/R/_common_report.R",
    package = "fnaufelRmd"
  )
)

# Opções para dfSummary
st_options(
  dfSummary.graph.col = FALSE,
)


# 3 casas decimais em números no texto
options(fmdigits = 3)

# Para mapas interativos
library(leaflet)

# Para gráficos lado a lado
library(patchwork)
```


# Instruções {-}

* Veja na tabela abaixo os números das questôes que foram sorteadas para você. [Se seu número de matrícula não estiver na tabela, entre em contato comigo pelo Telegram.]{.hl}

    ```{r echo=FALSE}
    set.seed(1235)
    eda <- sample(1:20)
    viz1 <- sample(1:20)
    viz2 <- sample(21:40)
    mapa <- 1
    matriculas <- c(
      '218060052',
      '115060047',
      '119060011',
      '218060076',
      '119060025',
      '218060053',
      '120060005',
      '020060003',
      '920060073',
      '219060086',
      '220060047',
      '120060009',
      '218060070',
      '020060001',
      '114060043',
      '119060007',
      '220060059',
      '120060007',
      '220060063',
      '118060029'      
    )
    
    tibble(
      matrícula = matriculas,
      'análise exploratória' = paste0('2.', as.character(eda), ','),
      'visualização' = paste0(
        paste0('3.', as.character(viz1)),
        ', ',
        paste0('3.', as.character(viz2)),
        ','
      ),
      'mapa' = '4.1'
    ) %>% 
      arrange(matrícula) %>% 
      kbl(
        align = 'r',
        col.names = c(
          'matrícula',
          '', '', ''
        )
      ) %>% 
      kable_paper(
        c('striped', 'hover'),
        full_width = FALSE
      )
    ```

* Clique o botão `Code`, no início desta página, para baixar o arquivo Rmd deste documento.

* Edite o arquivo Rmd para resolver as suas questões. 

* Se quiser resolver questões que não foram sorteadas para você, fique à vontade. Na verdade, em alguns casos, uma questão sua pode depender da resposta da questão de outro aluno.

* Escreva o máximo possível sobre o seu raciocínio. Justifique suas respostas.

* Teste suas respostas. Tudo deve estar executando sem erros.

* [Envie no Moodle: ]{.hl}

  1. O arquivo Rmd com as suas resoluções e
  
  1. Um vídeo de até $5$ minutos explicando as suas resoluções.

* Bom trabalho.


# Ambiente {-}

* Para gerar um arquivo HTML a partir deste documento, você precisa dos seguintes pacotes do R:

  ```{r echo=FALSE, results='asis'}
  pacotes <- session_info('attached')$packages$package
  pacotes_tidy <- getNamespace("tidyverse")$core
  pacotes <- c(
    setdiff(pacotes, pacotes_tidy),
    'fnaufelRmd',
    'devtools'
  ) %>% 
    sort()
   
  paste('  * `', pacotes, '`', collapse = '\n\n') %>% 
    cat()
  ```

* Se você estiver usando o Ubuntu, você precisa instalar --- [pelo sistema, não pelo R]{.hl} --- o pacote `libgdal-dev`. Faça isto [antes]{.hl} de executar o código abaixo.

* Execute o seguinte código para instalar os pacotes que estão faltando no seu ambiente:

    ```{r message=FALSE}
    if (!require('devtools'))
      install.packages('devtools')
    
    if (!require('fnaufelRmd'))
      devtools::install_github("fnaufel/fnaufelRmd")
    
    pacotes <- c(
      'conflicted',
      'kableExtra',
      'knitr',
      'latex2exp',
      'leaflet',
      'sessioninfo',
      'summarytools',
      'tidyverse'
    )
    
    instalar_se_preciso <- function(x) {
      
      if (!require(x, character.only = TRUE))
        install.packages(x)
      
    }
    
    invisible(sapply(pacotes, instalar_se_preciso))
    ```

* Se houver erro na instalação, entre em contato comigo pelo Telegram, [enviando todas as mensagens emitidas quando você executou os comandos]{.hl}.


# Leitura e limpeza dos dados

1. Os nomes das colunas originais estão em inglês. Para ver o [dicionário de dados]{.hl} --- documentação sobre cada uma das colunas --- visite https://www.kaggle.com/datasets/crisparada/brazilian-cities?select=Data_Dictionary.csv.

1. Eis uma função para renomear as colunas para português. Ela simplesmente retorna um vetor com os novos nomes, na mesma ordem que as colunas originais.

    ```{r}
    renomear <- function(x) {
      
      c(
        'cidade',
        'estado',
        'capital',
        'pop_resid',
        'pop_resid_bras',
        'pop_resid_estr',
        'unidades_domest',
        'unidades_domest_urban',
        'unidades_domest_rural',
        'pop_regular',
        'pop_regular_1',
        'pop_regular_1_4',
        'pop_regular_5_9',
        'pop_regular_10_14',
        'pop_regular_15_59',
        'pop_regular_60_mais',
        'area_cultivada',
        'producao_rural',
        'idhm_ranking',
        'idhm',
        'idhm_renda',
        'idhm_longevidade',
        'idhm_educacao',
        'longitude',
        'latitude',
        'altitude',
        'tv_assinatura',
        'telefones_fixos',
        'area',
        'regiao_turismo',
        'categoria_turismo',
        'pop_estimada',
        'tipo',
        'gva_agropec',
        'gva_industria',
        'gva_servicos',
        'gva_publico',
        'gva_total',
        'impostos',
        'pib',
        'pop_pib',
        'pib_capita',
        'atividade_principal',
        'despesas_municipais',
        'empresas_tot',
        'empresas_a',
        'empresas_b',
        'empresas_c',
        'empresas_d',
        'empresas_e',
        'empresas_f',
        'empresas_g',
        'empresas_h',
        'empresas_i',
        'empresas_j',
        'empresas_k',
        'empresas_l',
        'empresas_m',
        'empresas_n',
        'empresas_o',
        'empresas_p',
        'empresas_q',
        'empresas_r',
        'empresas_s',
        'empresas_t',
        'empresas_u',
        'hoteis',
        'camas',
        'agencias_priv',
        'agencias_publ',
        'bancos_priv',
        'bancos_publ',
        'patrimonio_bancos_priv',
        'patrimonio_bancos_publ',
        'carros',
        'motos',
        'tratores',
        'uber',
        'mac',
        'walmart',
        'correios'
      )
      
    }
    ```

1. Ler os dados, renomear as colunas e mudar o tipo de duas delas:

    ```{r}
    cidades <- read_csv(
      'dados/BRAZIL_CITIES_REV2022.CSV'
    ) %>% 
      rename_with(.fn = renomear) %>% 
      mutate(
        capital = as.logical(capital),
        uber = as.logical(uber)
      )
    ```

1. Examinar a *tibble* com `dfSummary`:

    ```{r cache=TRUE}
    cidades %>% 
      dfSummary() %>% 
      print(method = 'render')
    ```


# Análise exploratória {#eda}

## IDHM

1. Pesquise o que é IDHM.

   ::: {.rmdbox latex=1}
   
   Segundo a [Wikipedia (consultada em 02/06/2022)](https://pt.wikipedia.org/wiki/%C3%8Dndice_de_Desenvolvimento_Humano_Municipal):
   
   > O Índice de Desenvolvimento Humano Municipal é uma versão modificada do IDH usado para calcular o IDH das unidades federativas do Brasil. Por ser uma versão modificada do IDH, não é recomendada a comparação com outros países que usam o IDH padrão.
   
   > Foi criado para ser um índice similar ao IDH que se adequasse à demografia brasileira.
     
   > O índice tem 3 indicadores: IDHM Longevidade, IDHM Educação, IDHM Renda.

   :::
   
1. Qual o valor máximo possível? Qual o valor máximo na *tibble*?

   ::: {.rmdbox latex=1}
   
   Segundo [a mesma fonte](https://pt.wikipedia.org/wiki/%C3%8Dndice_de_Desenvolvimento_Humano_Municipal), o valor máximo é $1$.
   
   Na *tibble*, o valor máximo é
   
    ```{r}
    cidades %>%
      slice_max(idhm, n = 1) %>% 
      select(cidade, estado, idhm)
    ```
   
   :::
   
     
## Estados e capitais

1. Compare a quantidade de estados com a quantidade de capitais. O que está errado? Conserte a situação.

   ::: {.rmdbox latex=1}
   
   Como `capital` é uma coluna booleana, usamos `sum` para obter a quantidade de municípios para os quais `capital` é verdadeiro:

    ```{r}
    cidades %>% 
      summarize(
        estados = n_distinct(estado),
        capitais = sum(capital)
      )
    ```
    
   As quantidades são diferentes!
   
   Listando as capitais com seus respectivos estados:
   
    ```{r}
    cidades %>% 
      filter(capital) %>% 
      select(estado, cidade) %>% 
      arrange(estado)
    ```

   Em alguns estados, existem cidades --- não-capitais --- que têm o mesmo nome que capitais de outros estados. Estas cidades estão marcadas como capitais.
   
    ```{r}
    repetidas <- cidades %>% 
      filter(capital) %>% 
      select(estado, cidade) %>% 
      arrange(estado) %>% 
      add_count(estado) %>% 
      filter(n > 1)
    
    repetidas
    ```

   Vamos consertar:
   
    ```{r}
    nao_capitais <- repetidas %>% 
      slice(-c(3, 4, 8, 9))
    
    cidades <- cidades %>% 
      mutate(
        capital = case_when(
          !(estado %in% nao_capitais$estado) ~ capital, 
          !(cidade %in% nao_capitais$cidade) ~ capital, 
          TRUE ~ FALSE
        )
      )
    ```
   
   E conferir:

    ```{r}
    cidades %>% 
      filter(capital) %>% 
      select(estado, cidade) %>% 
      arrange(estado)
    ```
   
   :::


## Populações

1. Verifique se a coluna `pop_resid` (população de residentes) é a soma de `pop_resid_bras` (população de residentes brasileiros) com `pop_resid_estr` (população de residentes estrangeiros). Use a função `all`.

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      summarize(
        all(pop_resid == pop_resid_bras + pop_resid_estr)
      )
    ```
   
   Sim.
   
   :::


## Unidades domésticas

1. Verifique se a coluna `unidades_domest` (unidades domésticas) é a soma de `unidades_domest_urban` (urbanas) com `unidades_domest_rural` (rurais). Use a função `all`.

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      summarize(
        all(
          unidades_domest == unidades_domest_urban + unidades_domest_rural
        )
      )
    ```

   Não.
   
    ```{r}
    dif <- cidades %>% 
      mutate(
        diferenca = 
          unidades_domest - unidades_domest_urban - unidades_domest_rural
      ) %>% 
      filter(
        diferenca != 0
      ) %>% 
      select(cidade, diferenca)
    
    dif
    
    dif %>% 
      distinct(diferenca)
    ```
   
   A diferença nunca é maior que $1$.

   :::
   

## Categorias de turismo

1. Na coluna `categoria_turismo`, substitua os zeros por `NA` e converta tudo para um [fator ordenado]{.hl} com níveis $E < D < C < B < A$. Use a função `factor`.

   ::: {.rmdbox latex=1}
   
    ```{r}
    categoria_fator <- cidades %>% 
      pull(categoria_turismo) %>% 
      factor(
        levels = c('E', 'D', 'C', 'B', 'A'),
        ordered = TRUE
      )
    ```

    ```{r}
    cidades <- cidades %>% 
      mutate(
        categoria_turismo = categoria_fator
      )
    ```
   
    ```{r}
    cidades %>% 
      count(categoria_turismo)
    ```
   
   :::


## Tipos

1. Na coluna `tipo`, substitua os zeros por `NA` e converta tudo para um [fator não-ordenado]{.hl}.

   ::: {.rmdbox latex=1}
   
    ```{r}
    tipo_fator <- cidades %>% 
      pull(tipo)

    tipo_fator[tipo_fator == '0'] <- NA
    
    tipo_fator <- factor(tipo_fator, ordered = FALSE)
    ```

    ```{r}
    cidades <- cidades %>% 
      mutate(
        tipo = tipo_fator
      )
    ```
   
    ```{r}
    cidades %>% 
      count(tipo)
    ```
   
   :::


## Atividades principais

1. Na coluna `atividade_principal`, substitua os zeros por `NA` e converta tudo para um [fator não-ordenado]{.hl}.

   ::: {.rmdbox latex=1}
   
    ```{r}
    ap_fator <- cidades %>% 
      pull(atividade_principal)

    ap_fator[ap_fator == '0'] <- NA
    
    ap_fator <- factor(ap_fator, ordered = FALSE)
    ```

    ```{r}
    cidades <- cidades %>% 
      mutate(
        atividade_principal = ap_fator
      )
    ```
   
    ```{r}
    cidades %>% 
      count(atividade_principal)
    ```
   
   :::


## Regiões geográficas {#regioes-geo}

1. Crie uma nova coluna, [do tipo fator]{.hl}, chamada `regiao`, com a região geográfica (Norte, Nordeste, Centro-Oeste, Sudeste, ou Sul) onde está cada município. Use os níveis 'N', 'NE', 'CO', 'SE', 'S'.

   ::: {.rmdbox latex=1}
   
    ```{r}
    estados <- unique(cidades$estado) %>% sort()
    
    regioes <- c(
      'N', 'NE', 'N', 'N', 'NE', 'NE', 'CO', 'SE', 'CO', 'NE', 
      'SE', 'CO', 'CO', 'N', 'NE', 'NE', 'NE', 'S', 'SE', 'NE', 
      'N', 'N', 'S', 'S', 'NE', 'SE', 'N'
    )
    
    names(regioes) <- estados
    
    cidades <- cidades %>% 
      mutate(
        regiao = factor(regioes[estado])
      )
    ```
    
    ```{r}
    cidades %>%
      distinct(regiao, estado) %>% 
      arrange(regiao)
    ```
    
   :::


## Regiões de turismo

1. Na coluna `regiao_turismo`, substitua os zeros por `NA`.

   ::: {.rmdbox latex=1}
   
   Quantos zeros são?
   
    ```{r}
    cidades %>% 
      count(regiao_turismo == '0')
    ```

    ```{r}
    cidades <- cidades %>% 
      mutate(
        regiao_turismo = 
          if_else(
            regiao_turismo == '0', NA_character_, regiao_turismo
          )
      )
    ```
   
   Vamos conferir:
   
    ```{r}
    cidades %>% 
      count(regiao_turismo == '0')
    ```

    ```{r}
    cidades %>% 
      count(is.na(regiao_turismo))
    ```
   
   :::
   

1. Quantas regiões de turismo são?

   ::: {.rmdbox latex=1}
   
    ```{r}
    n_distinct(cidades$regiao_turismo, na.rm = TRUE)
    ```
   
   :::
   
1. Qual tem mais municípios?

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      filter(!is.na(regiao_turismo)) %>% 
      group_by(regiao_turismo) %>% 
      summarize(municipios = n()) %>% 
      slice_max(municipios, n = 1)
    ```
   
   :::
   
1. Qual tem menos municípios?

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      filter(!is.na(regiao_turismo)) %>% 
      group_by(regiao_turismo) %>% 
      summarize(municipios = n()) %>% 
      slice_min(municipios, n = 1)
    ```
   
   :::

1. Quantos municípios não fazem parte de região de turismo?

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      filter(is.na(regiao_turismo)) %>% 
      nrow()
    ```
   
   :::
   
1. Existe alguma região de turismo contendo cidades de estados diferentes?

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      filter(!is.na(regiao_turismo)) %>% 
      group_by(regiao_turismo) %>% 
      summarise(estados = n_distinct(estado)) %>% 
      filter(estados > 1)
    ```
   
   :::


## Nomes das regiões de turismo

1. Gere uma *tibble* com todos os valores distintos de `regiao_turismo`, sem repetições. 

1. Quais são as $10$ palavras mais comuns que iniciam os nomes de regiões de turismo? Use a função `word`.
   
   ::: {.rmdbox latex=1}
   
    ```{r}
    mais_comuns <- cidades %>% 
      distinct(regiao_turismo) %>% 
      transmute(primeira = word(regiao_turismo)) %>% 
      count(primeira, sort = TRUE) %>% 
      head(10)
    
    mais_comuns
    ```
   
   :::

1. Liste, em ordem alfabética, os nomes completos das regiões de turismo cujos nomes começam com palavras desta lista. 

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      distinct(regiao_turismo) %>% 
      filter(
        word(regiao_turismo) %in% mais_comuns$primeira
      ) %>% 
      select(regiao_turismo) %>% 
      arrange(regiao_turismo)
    ```
   
   :::


## PIB

1. Verifique se a coluna `pib_capita` é o resultado da divisão de `pib` por `pop_pib`. Use a função `all`.


## Carros

1. Quais as $10$ cidades que têm a [maior quantidade de carros por habitante]{.hl}?

   ::: {.rmdbox latex=1}
   
   Se usarmos `pop_regular`, algumas cidades têm zero neste campo:
   
    ```{r}
    cidades %>% 
      mutate(
        carros_por_habitante = carros / pop_regular
      ) %>% 
      slice_max(carros_por_habitante, n = 10) %>% 
      select(cidade, estado, carros_por_habitante, pop_regular)
    ```

   Vamos excluí-las:
   
    ```{r}
    carros_pop_regular <- cidades %>% 
      filter(pop_regular > 0) %>% 
      mutate(
        carros_por_habitante = carros / pop_regular
      ) %>% 
      slice_max(carros_por_habitante, n = 10) %>% 
      select(cidade, estado, carros_por_habitante, tipo)
    
    carros_pop_regular
    ```   

   Ou podemos usar a população residente, também eliminando as cidades com zero neste campo:
   
    ```{r}
    carros_pop_resid <- cidades %>% 
      filter(pop_resid > 0) %>% 
      mutate(
        carros_por_habitante = carros / pop_resid
      ) %>% 
      slice_max(carros_por_habitante, n = 10) %>% 
      select(cidade, estado, carros_por_habitante, tipo)
    
    carros_pop_resid
    ```      

   Ou podemos usar a população estimada, onde as cidades com zero habitantes têm zero carros --- e o R calcula $0/0$ como `NaN`, não como `Inf`:
   
    ```{r}
    carros_pop_est <- cidades %>% 
      mutate(
        carros_por_habitante = carros / pop_estimada
      ) %>% 
      slice_max(carros_por_habitante, n = 10) %>% 
      select(cidade, estado, carros_por_habitante, tipo)
    
    carros_pop_est
    ```   

   Vamos comparar:

    ```{r}
    tibble(
      regular = paste(
        carros_pop_regular$cidade,
        carros_pop_regular$estado,
        sep = ', '
      ),
      resid = paste(
        carros_pop_resid$cidade,
        carros_pop_resid$estado,
        sep = ', '
      ),
      estim = paste(
        carros_pop_est$cidade,
        carros_pop_est$estado,
        sep = ', '
      )
    )
    ```

   :::

1. Quais as $10$ cidades que têm a [menor quantidade de carros por habitante]{.hl}?

   ::: {.rmdbox latex=1}
   
   Vamos ignorar as cidades com zero carros.
   
   Usando a população regular:
   
    ```{r}
    carros_pop_regular <- cidades %>%
      filter(carros > 0) %>% 
      mutate(
        carros_por_habitante = carros / pop_regular
      ) %>% 
      slice_min(carros_por_habitante, n = 10) %>% 
      select(cidade, estado, carros_por_habitante, tipo)
    
    carros_pop_regular
    ```

   Usando a população residente:
   
    ```{r}
    carros_pop_resid <- cidades %>% 
      filter(carros > 0) %>% 
      mutate(
        carros_por_habitante = carros / pop_resid
      ) %>% 
      slice_min(carros_por_habitante, n = 10) %>% 
      select(cidade, estado, carros_por_habitante, tipo)
    
    carros_pop_resid
    ```      

   Usando a população estimada:
   
    ```{r}
    carros_pop_est <- cidades %>% 
      filter(carros > 0) %>% 
      mutate(
        carros_por_habitante = carros / pop_estimada
      ) %>% 
      slice_min(carros_por_habitante, n = 10) %>% 
      select(cidade, estado, carros_por_habitante, tipo)
    
    carros_pop_est
    ```   

   Vamos comparar:

    ```{r}
    tibble(
      regular = paste(
        carros_pop_regular$cidade,
        carros_pop_regular$estado,
        sep = ', '
      ),
      resid = paste(
        carros_pop_resid$cidade,
        carros_pop_resid$estado,
        sep = ', '
      ),
      estim = paste(
        carros_pop_est$cidade,
        carros_pop_est$estado,
        sep = ', '
      )
    )
    ```

   :::

1. Quais são os tipos destas cidades?

   ::: {.rmdbox latex=1}
   
   Já incluídos nos resultados acima.
   
   :::
   
1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   As cidades com [mais]{.hl} carros por habitante são todas da região Sul ou Sudeste.
   
   Por um dos critérios, são todas do tipo rural adjacente.
   
   As únicas capitais que aparecem são Belo Horizonte e Curitiba.
   
   As cidades com [menos]{.hl} carros por habitante são todas da região Norte, onde o transporte rodoviário é pouco desenvolvido.
   
   São todas do tipo rural remoto ou intermediário remoto.
   
   :::
   

## Motos

1. Quais as $10$ cidades que têm a [maior quantidade de motos por habitante]{.hl}?

   ::: {.rmdbox latex=1}
   
   Se usarmos `pop_regular`, algumas cidades têm zero neste campo:
   
    ```{r}
    cidades %>% 
      mutate(
        motos_por_habitante = motos / pop_regular
      ) %>% 
      slice_max(motos_por_habitante, n = 10) %>% 
      select(cidade, estado, motos_por_habitante, pop_regular)
    ```

   Vamos excluí-las:
   
    ```{r}
    motos_pop_regular <- cidades %>% 
      filter(pop_regular > 0) %>% 
      mutate(
        motos_por_habitante = motos / pop_regular
      ) %>% 
      slice_max(motos_por_habitante, n = 10) %>% 
      select(cidade, estado, motos_por_habitante, tipo)
    
    motos_pop_regular
    ```   

   Ou podemos usar a população residente, também eliminando as cidades com zero neste campo:
   
    ```{r}
    motos_pop_resid <- cidades %>% 
      filter(pop_resid > 0) %>% 
      mutate(
        motos_por_habitante = motos / pop_resid
      ) %>% 
      slice_max(motos_por_habitante, n = 10) %>% 
      select(cidade, estado, motos_por_habitante, tipo)
    
    motos_pop_resid
    ```      

   Ou podemos usar a população estimada, onde as cidades com zero habitantes têm zero motos --- e o R calcula $0/0$ como `NaN`, não como `Inf`:
   
    ```{r}
    motos_pop_est <- cidades %>% 
      mutate(
        motos_por_habitante = motos / pop_estimada
      ) %>% 
      slice_max(motos_por_habitante, n = 10) %>% 
      select(cidade, estado, motos_por_habitante, tipo)
    
    motos_pop_est
    ```   

   Vamos comparar:

    ```{r}
    tibble(
      regular = paste(
        motos_pop_regular$cidade,
        motos_pop_regular$estado,
        sep = ', '
      ),
      resid = paste(
        motos_pop_resid$cidade,
        motos_pop_resid$estado,
        sep = ', '
      ),
      estim = paste(
        motos_pop_est$cidade,
        motos_pop_est$estado,
        sep = ', '
      )
    )
    ```

   :::

1. Quais as $10$ cidades que têm a [menor quantidade de motos por habitante]{.hl}?

   ::: {.rmdbox latex=1}
   
   Vamos ignorar as cidades com zero motos.
   
   Usando a população regular:
   
    ```{r}
    motos_pop_regular <- cidades %>%
      filter(motos > 0) %>% 
      mutate(
        motos_por_habitante = motos / pop_regular
      ) %>% 
      slice_min(motos_por_habitante, n = 10) %>% 
      select(cidade, estado, motos_por_habitante, tipo)
    
    motos_pop_regular
    ```

   Usando a população residente:
   
    ```{r}
    motos_pop_resid <- cidades %>% 
      filter(motos > 0) %>% 
      mutate(
        motos_por_habitante = motos / pop_resid
      ) %>% 
      slice_min(motos_por_habitante, n = 10) %>% 
      select(cidade, estado, motos_por_habitante, tipo)
    
    motos_pop_resid
    ```      

   Usando a população estimada:
   
    ```{r}
    motos_pop_est <- cidades %>% 
      filter(motos > 0) %>% 
      mutate(
        motos_por_habitante = motos / pop_estimada
      ) %>% 
      slice_min(motos_por_habitante, n = 10) %>% 
      select(cidade, estado, motos_por_habitante, tipo)
    
    motos_pop_est
    ```   

   Vamos comparar:

    ```{r}
    tibble(
      regular = paste(
        motos_pop_regular$cidade,
        motos_pop_regular$estado,
        sep = ', '
      ),
      resid = paste(
        motos_pop_resid$cidade,
        motos_pop_resid$estado,
        sep = ', '
      ),
      estim = paste(
        motos_pop_est$cidade,
        motos_pop_est$estado,
        sep = ', '
      )
    )
    ```

   :::

1. Quais são os tipos destas cidades?

   ::: {.rmdbox latex=1}
   
   Já incluídos nos resultados acima.
   
   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   Por dois dos critérios, as cidades com [mais]{.hl} motos por habitante são todas da região Norte ou Nordeste.
   
   São do tipo rural adjacente ou urbano.
   
   As cidades com [menos]{.hl} motos por habitante são todas da região Norte, onde o transporte rodoviário é pouco desenvolvido.
   
   São todas do tipo rural remoto ou rural adjacente.
   
   :::


## Tratores

1. Quais as $10$ cidades que têm a [maior quantidade de tratores por habitante]{.hl}? Ignore as cidades que têm zero tratores.

1. Quais as $10$ cidades que têm a [menor quantidade de tratores por habitante]{.hl}? Ignore as cidades que têm zero tratores.

1. Quais são os tipos destas cidades?

1. Comente os resultados.


## Áreas

1. Quais as $10$ cidades que têm a [maior área]{.hl}?

1. Quais as $10$ cidades que têm a [menor área]{.hl}?

1. Quais são os tipos destas cidades?

1. Comente os resultados.


## Produção rural

1. Quais as $10$ cidades que têm a [maior produção rural]{.hl}?

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      slice_max(producao_rural, n = 10) %>% 
      select(cidade, estado, producao_rural, tipo)
    ```

   :::
   
1. Quais as $10$ cidades que têm a [menor produção rural]{.hl}?

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      filter(producao_rural > 0) %>% 
      slice_min(producao_rural, n = 10) %>% 
      select(cidade, estado, producao_rural, tipo)
    ```

   :::

1. Quais são os tipos destas cidades? Ignore as cidades que têm zero produção rural.

   ::: {.rmdbox latex=1}
   
   Já incluídos nas tabelas acima.
   
   :::
   
1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   Muitas cidades do tipo urbano na lista de maiores produções rurais.
   
   :::
   

## Produção rural *per capita*

1. Quais as $10$ cidades que têm a [maior produção rural *per capita*]{.hl}?

1. Quais as $10$ cidades que têm a [menor produção rural *per capita*]{.hl}?

1. Quais são os tipos destas cidades? Ignore as cidades que têm zero produção rural.

1. Comente os resultados.


## Densidade demográfica

1. Quais as $10$ cidades que têm a [maior densidade demográfica]{.hl}?

   ::: {.rmdbox latex=1}
   
   Vamos usar a população residente.
   
    ```{r}
    cidades_dd <- cidades %>% 
      mutate(
        dens = pop_resid / area
      )
    ```

    ```{r}
    cidades_dd %>% 
      slice_max(dens, n = 10) %>% 
      select(cidade, estado, dens, tipo)
    ```

   :::
   
1. Quais as $10$ cidades que têm a [menor densidade demográfica]{.hl}?

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades_dd %>% 
      slice_min(dens, n = 10) %>% 
      select(cidade, estado, dens, tipo)
    ```
   
   Problema: há cidades com zero habitantes. Vamos ignorá-las:
   
    ```{r}
    cidades_dd %>% 
      filter(dens > 0) %>% 
      slice_min(dens, n = 10) %>% 
      select(cidade, estado, dens, tipo)
    ```
   
   :::
   
1. Quais são os tipos destas cidades? 

   ::: {.rmdbox latex=1}
   
   Incluídos nas tabelas acima.
   
   :::
   
1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   Com exceção de Olinda e Fortaleza, as cidades de maior densidade demográfica estão no Rio de Janeiro e em São Paulo.
   
   As de menor densidade demográfica ficam na região Norte, com exceção de Rondolândia.
   
   :::
   

## Cidades extremas

1. Quais são as $10$ cidades de [maior e menor latitude]{.hl}?

   ::: {.rmdbox latex=1}
   
   Maior latitude:
   
    ```{r}
    cidades %>% 
      slice_max(latitude, n = 10) %>% 
      select(cidade, estado, latitude)    
    ```

   Menor latitude:
   
    ```{r}
    cidades %>% 
      slice_min(latitude, n = 10) %>% 
      select(cidade, estado, latitude)    
    ```
   
   A expressão "do Oiapoque ao Chuí" não é exata. O certo parece ser "de Uiramutã ao Chuí".
   
   :::

1. Quais são as $10$ cidades de [maior e menor longitude]{.hl}?

   ::: {.rmdbox latex=1}
   
   Maior longitude:
   
    ```{r}
    cidades %>% 
      slice_max(longitude, n = 10) %>% 
      select(cidade, estado, longitude)    
    ```

   Temos um problema: longitude zero é em Londres! 
   
   Os dados estão errados. Vamos ignorar cidades com zero no campo `longitude`:
   
    ```{r}
    cidades %>% 
      filter(longitude != 0) %>% 
      slice_max(longitude, n = 10) %>% 
      select(cidade, estado, longitude)    
    ```
   
   Menor longitude:
   
    ```{r}
    cidades %>% 
      slice_min(longitude, n = 10) %>% 
      select(cidade, estado, longitude)    
    ```
   
   :::

1. Quais são as $10$ cidades de [maior e menor altitude]{.hl}?

   ::: {.rmdbox latex=1}
   
   Maior altitude:
   
    ```{r}
    cidades %>% 
     slice_max(altitude, n = 10) %>% 
     select(cidade, estado, altitude)    
    ```

   Menor altitude:
   
    ```{r}
    cidades %>% 
     slice_min(altitude, n = 10) %>% 
     select(cidade, estado, altitude)    
    ```
   
   :::

1. Responda as perguntas acima [por região geográfica]{.hl}. Você vai precisar da resposta [desta questão](#regioes-geo).

   ::: {.rmdbox latex=1}
   
   Latitude:
   
   Só a região Norte pode ter cidades com latitude zero.
   
    ```{r}
    cidades %>% 
      filter(latitude != 0 | regiao == 'N') %>% 
      group_by(regiao) %>% 
      slice_max(latitude, n = 10) %>% 
      select(cidade, estado, regiao, latitude)
    ```
   
    ```{r}
    cidades %>% 
      group_by(regiao) %>% 
      slice_min(latitude, n = 10) %>% 
      select(cidade, estado, regiao, latitude)
    ```
   
   Longitude:
   
    ```{r}
    cidades %>% 
      filter(longitude != 0) %>% 
      group_by(regiao) %>% 
      slice_max(longitude, n = 10) %>% 
      select(cidade, estado, regiao, longitude)
    ```
   
    ```{r}
    cidades %>% 
      filter(longitude != 0) %>% 
      group_by(regiao) %>% 
      slice_min(longitude, n = 10) %>% 
      select(cidade, estado, regiao, longitude)
    ```

   Altitude:
   
    ```{r}
    cidades %>% 
      group_by(regiao) %>% 
      slice_max(altitude, n = 10) %>% 
      select(cidade, estado, regiao, altitude)
    ```
   
    ```{r}
    cidades %>% 
      group_by(regiao) %>% 
      slice_min(altitude, n = 10) %>% 
      select(cidade, estado, regiao, altitude)
    ```

   :::


## Faixas etárias

1. Quais as $10$ cidades com a [maior proporção de idosos (60 anos ou mais)]{.hl}?

1. Quais as $10$ cidades com a [menor proporção de idosos (60 anos ou mais)]{.hl}?

1. Quais são os tipos destas cidades? 

1. Comente os resultados.


# Visualização

::: {.rmdimportant latex=1}

* Todos os gráficos devem ser feitos com o pacote ggplot2.

* Todos os gráficos devem incluir títulos, rótulos, legendas, e outros elementos para facilitar a compreensão. Imagine que seus gráficos serão publicados em uma revista científica.

:::


## População e McDonald's

1. [Apenas para as cidades que têm McDonald's]{.hl}, faça um *scatterplot* de quantidade de McDonald's (no eixo $y$) por população (no eixo $x$).

   ::: {.rmdbox latex=1}
   
    ```{r}
    grafico <- cidades %>% 
      filter(mac > 0) %>% 
      ggplot(
        aes(x = pop_resid, y = mac)
      ) +
        geom_point() +
        scale_x_continuous(
          labels = scales::number_format(
            scale = 1e-6,
            suffix = 'M'
          )
        ) +
        labs(
          title = 'Quantidade de McDonald\'s por população',
          x = 'população',
          y = 'Qtde de\nMcDonald\'s'
        )
    
    grafico
    ```
   
   Restringindo a cidades de até $2$ milhões de habitantes, eliminando os *outliers*:
   
    ```{r}
    grafico2 <- grafico +
      scale_x_continuous(
        limits = c(0, 2e6),
        labels = scales::number_format(
          scale = 1e-6,
          suffix = 'M'
        )
      )
    
    grafico2
    ```
   
   
   :::
   
1. Use `geom_smooth` para gerar uma reta de regressão (com `method = 'lm'` e `se = FALSE`).

   ::: {.rmdbox latex=1}
   
    ```{r}
    grafico +
      geom_smooth(
        method = 'lm',
        se = FALSE
      )
    ```

   Restringindo a cidades de até $2$ milhões de habitantes, eliminando os *outliers*:

    ```{r}
    grafico2 +
      geom_smooth(
        method = 'lm',
        se = FALSE
      )
    ```
   
   :::
   
1. Existe alguma correlação entre as quantidades? Comente.

   ::: {.rmdbox latex=1}
   
   Sim, mas quando retiramos os *outliers*, a correlação diminui:
   
    ```{r}
    df <- cidades %>% 
      filter(mac > 0)
      
    cor(df$pop_resid, df$mac)
    
    df <- df %>% 
      filter(pop_resid < 2e6)
    
    cor(df$pop_resid, df$mac)
    ```
   
   :::
   

## População e Walmart

1. [Apenas para as cidades que têm Walmart]{.hl}, faça um *scatterplot* de quantidade de Walmarts (no eixo $y$) por população (no eixo $x$).

1. Use `geom_smooth` para gerar uma reta de regressão (com `method = 'lm'` e `se = FALSE`).

1. Existe alguma correlação entre as quantidades? Comente.


## IDHM e PIB *per capita*

1. Faça um *scatterplot* de IDHM (no eixo $y$) por PIB *per capita* (no eixo $x$).

1. Use `geom_smooth` para gerar uma reta de regressão (com `method = 'lm'` e `se = FALSE`).

1. Existe alguma correlação entre as quantidades? Comente.


## IDHM e despesas municipais

1. Faça um *scatterplot* de IDHM (no eixo $y$) por despesas municipais (no eixo $x$).

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_point(
          aes(x = despesas_municipais, y = idhm)
        ) +
        scale_x_continuous(
          labels = scales::number_format(
            scale = 1e-9
          )
        ) +
        labs(
          title = 'IDHM por despesas municipais',
          x = 'despesas municipais\n(bilhões R$)',
          y = 'IDHM'
        )
    ```
   
   Horrível. Vamos limitar a despesas maiores que zero e menores que $1$ bilhão, e ignorar as cidades com IDHM igual a zero:

    ```{r}
    grafico <- 
      cidades %>% 
        filter(
          between(despesas_municipais, 1, 1e9),
          idhm > 0
        ) %>% 
        ggplot(
          aes(x = despesas_municipais, y = idhm)
        ) +
          geom_point() +
          scale_x_continuous(
            labels = scales::number_format(
              scale = 1e-6
            )
          ) +
          labs(
            title = 'IDHM por despesas municipais',
            x = 'despesas municipais\n(milhões R$)',
            y = 'IDHM'
          )
    
    grafico
    ```
   
   :::
   
1. Use `geom_smooth` para gerar uma reta de regressão (com `method = 'lm'` e `se = FALSE`).

   ::: {.rmdbox latex=1}
   
    ```{r}
    grafico +
      geom_smooth(method = 'lm', se = FALSE)
    ```
   
   :::
   
1. Existe alguma correlação entre as quantidades? Comente.

   ::: {.rmdbox latex=1}
   
   É razoável pensar que despesas municipais maiores estão associadas a um IDHM maior, por causa de investimentos em saúde, educação, etc.
   
   A reta de regressão mostra que sim, embora a correlação não seja tão grande:
   
    ```{r}
    cor(cidades$idhm, cidades$despesas_municipais)
    ```
   
   Existem cidades com despesas baixas e IDHM alto.
   
   Acima de $250$ milhões de despesas, nenhuma cidade tem IDHM menor que $0{,}6$. 
   
   :::
   

## IDHM e carros

1. Faça um *scatterplot* de IDHM (no eixo $y$) por quantidade de carros (no eixo $x$).

1. Use `geom_smooth` para gerar uma reta de regressão (com `method = 'lm'` e `se = FALSE`).

1. Existe alguma correlação entre as quantidades? Comente.


## IDHM e motos

1. Faça um *scatterplot* de IDHM (no eixo $y$) por quantidade de motos (no eixo $x$).

1. Use `geom_smooth` para gerar uma reta de regressão (com `method = 'lm'` e `se = FALSE`).

1. Existe alguma correlação entre as quantidades? Comente.


## IDHM e tratores

1. Faça um *scatterplot* de IDHM (no eixo $y$) por quantidade de tratores (no eixo $x$). Ignore as cidades que têm zero tratores.

1. Use `geom_smooth` para gerar uma reta de regressão (com `method = 'lm'` e `se = FALSE`).

1. Existe alguma correlação entre as quantidades? Comente.


## Correios

1. Faça um histograma da quantidade de agências de correios. Use o número de classes que você achar mais adequado.

1. Comente os resultados.


## Correios *per capita*

1. Faça um histograma da razão [(número de agências de correio) / (população)]{.hl}. Use o número de classes que você achar mais adequado.

1. Comente os resultados.


## Agências bancárias (públicas)

1. Faça um histograma da quantidade de agências bancárias públicas. Use o número de classes que você achar mais adequado.

   ::: {.rmdbox latex=1}
   
   Existem muitas cidades com zero agências públicas:
   
    ```{r}
    cidades %>% 
      count(agencias_publ)
    ```
   
   Vamos ignorá-las:
   
    ```{r}
    cidades %>% 
      filter(agencias_publ > 0) %>% 
      ggplot() +
        geom_histogram(aes(x = agencias_publ))
    ```
   
   Ainda assim, a grande quantidade de cidades com só uma agência faz o histograma ficar não-interessante. 
   
   Vamos fazer um histograma do [logaritmo]{.hl} do número de agências. 
   
    ```{r}
    publicas <- cidades %>% 
      filter(agencias_publ > 0) %>% 
      mutate(log_publ = log(agencias_publ, 2)) %>% 
      ggplot() +
        geom_histogram(
          aes(x = log_publ),
          breaks = 0:10
        ) +
        scale_x_continuous(
          labels = function(x) 2^x,
          breaks = 0:10
        ) +
        labs(
          title = 'Quantidade de agências públicas',
          subtitle = '(escala logarítmica)',
          x = 'agências',
          y = NULL
        ) +
        ylim(0, 2500) +
        theme(axis.text.x = element_text(angle = 45))
    
    publicas
    ```

   Perceba como os rótulos do eixo $x$ são as quantidades de agências, não os logaritmos.
   
   :::

1. Compare com a distribuição de agências privadas.

   ::: {.rmdbox latex=1}
   
    ```{r histograma-privadas, include=FALSE}
    privadas <- cidades %>% 
      filter(agencias_priv > 0) %>% 
      mutate(log_priv = log(agencias_priv, 2)) %>% 
      ggplot() +
        geom_histogram(
          aes(x = log_priv),
          breaks = 0:10
        ) +
        scale_x_continuous(
          labels = function(x) 2^x,
          breaks = 0:10
        ) +
        labs(
          title = 'Quantidade de agências privadas',
          subtitle = '(escala logarítmica)',
          x = 'agências',
          y = NULL
        ) +
        ylim(0, 2500) +
        theme(axis.text.x = element_text(angle = 45))
    
    privadas
    ```
   
   [Veja a distribuição de agências privadas aqui.](#ag%C3%AAncias-banc%C3%A1rias-privadas)

    ```{r}
    privadas + publicas
    ```
   
   Vamos ver alguma tabelas.
   
   Totais de agências:
   
    ```{r}
    cidades %>% 
      summarize(
        privadas = sum(agencias_priv),
        públicas = sum(agencias_publ)
      )
    ```
   
   [No total, existem mais agências de bancos privados!]{.hl}
   
   Quantidade de cidades atendidas:
   
    ```{r}
    cidades %>% 
      summarize(
        privadas = sum(agencias_priv > 0),
        públicas = sum(agencias_publ > 0)
      )
    ```
   
   [Existem mais cidades com pelo menos uma agência de banco público do que cidades com pelo menos uma agência de banco privado.]{.hl}
   
   Ou, comparando a quantidade de cidades [sem]{.hl} agências:
   
    ```{r}
    cidades %>% 
      summarize(
        sem_privadas = sum(agencias_priv == 0),
        sem_públicas = sum(agencias_publ == 0),
        sem_qualquer = sum(agencias_publ == 0 & agencias_priv == 0)
      )
    ```
   
   Lembre-se de que o total de cidades é
   
    ```{r}
    nrow(cidades)
    ```
   
   Ou seja, [cerca de $`r (100 * 2233/nrow(cidades)) %>% fm(0)`\%$ de cidades não têm agências bancárias, nem privadas, nem públicas!]{.hl}
   
   Aliás, existe alguma cidade que tenha agência privada, mas não pública? Quantas?
   
    ```{r}
    cidades %>% 
      filter(
        agencias_priv > 0 & agencias_publ == 0
      ) %>% 
      select(cidade, estado, starts_with('agencias'))
    ```
   
   E existe alguma cidade que tenha agência pública, mas não privada? Quantas?
   
    ```{r}
    cidades %>% 
      filter(
        agencias_priv == 0 & agencias_publ > 0
      ) %>% 
      select(cidade, estado, starts_with('agencias'))
    ```

   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   Comentários incluídos nas respostas acima.
   
   :::
   

## Agências bancárias (públicas) *per capita*

1. Faça um histograma da razão [(número de agências bancárias públicas) / (população)]{.hl}. Use o número de classes que você achar mais adequado.

   ::: {.rmdbox latex=1}
   
    ```{r privadas-per-capita, include=FALSE}
    privadaspc <- cidades %>% 
      filter(agencias_priv > 0) %>% 
      mutate(
        privadas_per_capita = agencias_priv / pop_resid
      ) %>% 
      ggplot() +
        geom_histogram(
          aes(x = privadas_per_capita),
          breaks = seq(0, .0009, .00005)
        ) +
        labs(
          title = 'Agências privadas per capita',
          x = 'agências',
          y = NULL
        ) +
        theme(axis.text.x = element_text(angle = 45)) +
        scale_y_continuous(
          breaks = seq(0, 1250, 250),
          limits = c(0, 1250)
        )
    
    privadaspc
    ```
   
   Existem muitas cidades com zero agências públicas:
   
    ```{r}
    cidades %>% 
      count(agencias_publ)
    ```
   
   Vamos ignorá-las.
   
    ```{r}
    publicaspc <- cidades %>% 
      filter(agencias_publ > 0) %>% 
      mutate(
        publicas_per_capita = agencias_publ / pop_resid
      ) %>% 
      ggplot() +
        geom_histogram(
          aes(x = publicas_per_capita),
          breaks = seq(0, .0009, .00005)
        ) +
        labs(
          title = 'Agências públicas per capita',
          x = 'agências',
          y = NULL
        ) +
        theme(axis.text.x = element_text(angle = 45))
    
    publicaspc
    ```
   
   :::

1. Compare com a distribuição de agências privadas.

   ::: {.rmdbox latex=1}
   
    ```{r}
    privadaspc + publicaspc
    ```

   Para quase todos os valores de agências *per capita*, existem mais cidades com agências públicas do que cidades com agências privadas. 
   
   Isto é consequência de que, no total, [existem mais cidades atendidas por bancos públicos do que por bancos privados](#ag%C3%AAncias-banc%C3%A1rias-p%C3%BAblicas).
   
   Mas eu devia ter pedido um *scatterplot* de agências por população para um *insight* interessante.
   
   Aqui, descartamos as cidades com mais de $3$ milhões de habitantes.
   
    ```{r}
    cidades %>% 
      filter(
        agencias_priv > 0,
        agencias_publ > 0,
        pop_resid < 3e6
      ) %>% 
      ggplot() +
        geom_point(
          aes(
            x = pop_resid, 
            y = agencias_publ, 
            color = 'publ'
          ),
          alpha = .4
        ) +
        geom_smooth(
          aes(
            x = pop_resid, 
            y = agencias_publ, 
            color = 'publ'
          ),
          method = 'lm',
          se = FALSE
        ) +
        geom_point(
          aes(
            x = pop_resid, 
            y = agencias_priv, 
            color = 'priv'
          ),
          alpha = .2
        ) +
        geom_smooth(
          aes(
            x = pop_resid, 
            y = agencias_priv, 
            color = 'priv'
          ),
          method = 'lm',
          se = FALSE
        ) +
        scale_color_discrete(
          type = c('blue', 'red')
        ) +
        scale_x_continuous(
          breaks = seq(0, 3e6, .5e6),
          labels = scales::label_number(
            scale = 1e-6,
            suffix = 'M'
          )
        ) +
        labs(
          title = 'Agências bancárias por população',
          x = 'população',
          y = 'agências',
          color = NULL
        )
    ```
   
   As retas mostram como o número de agências aumenta à medida que a população aumenta.
   
   Para os bancos privados, o aumento é mais rápido.
   
   Em outras palavras: [para uma mesma população]{.hl}, existem, em média, [mais agências privadas do que públicas]{.hl}, e, quanto maior a população, maior a diferença.

   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   Comentários incluídos nas respostas acima.
   
   :::


## Agências bancárias (privadas)

1. Faça um histograma da quantidade de agências bancárias privadas. Use o número de classes que você achar mais adequado.

   ::: {.rmdbox latex=1}
   
   Existem muitas cidades com zero agências privadas:
   
    ```{r}
    cidades %>% 
      count(agencias_priv)
    ```
   
   Vamos ignorá-las:
   
    ```{r}
    cidades %>% 
      filter(agencias_priv > 0) %>% 
      ggplot() +
        geom_histogram(aes(x = agencias_priv))
    ```
   
   Ainda assim, a grande quantidade de cidades com só uma agência faz o histograma ficar não-interessante. 
   
   Vamos fazer um histograma do [logaritmo]{.hl} do número de agências. 
   
    ```{r ref.label='histograma-privadas'}
    ```

   Perceba como os rótulos do eixo $x$ são as quantidades de agências, não os logaritmos.
   
   :::

1. Compare com a distribuição de agências públicas.

   ::: {.rmdbox latex=1}
   
   [Veja a distribuição de agências públicas aqui.](#ag%C3%AAncias-banc%C3%A1rias-p%C3%BAblicas)

    ```{r}
    privadas + publicas
    ```
   
   Vamos ver alguma tabelas.
   
   Totais de agências:
   
    ```{r}
    cidades %>% 
      summarize(
        privadas = sum(agencias_priv),
        públicas = sum(agencias_publ)
      )
    ```
   
   [No total, existem mais agências de bancos privados!]{.hl}
   
   Quantidade de cidades atendidas:
   
    ```{r}
    cidades %>% 
      summarize(
        privadas = sum(agencias_priv > 0),
        públicas = sum(agencias_publ > 0)
      )
    ```
   
   [Existem mais cidades com pelo menos uma agência de banco público do que cidades com pelo menos uma agência de banco privado.]{.hl}
   
   Ou, comparando a quantidade de cidades [sem]{.hl} agências:
   
    ```{r}
    cidades %>% 
      summarize(
        sem_privadas = sum(agencias_priv == 0),
        sem_públicas = sum(agencias_publ == 0),
        sem_qualquer = sum(agencias_publ == 0 & agencias_priv == 0)
      )
    ```
   
   Lembre-se de que o total de cidades é
   
    ```{r}
    nrow(cidades)
    ```
   
   Ou seja, [cerca de $`r (100 * 2233/nrow(cidades)) %>% fm(0)`\%$ de cidades não têm agências bancárias, nem privadas, nem públicas!]{.hl}
   
   Aliás, existe alguma cidade que tenha agência privada, mas não pública? Quantas?
   
    ```{r}
    cidades %>% 
      filter(
        agencias_priv > 0 & agencias_publ == 0
      ) %>% 
      select(cidade, estado, starts_with('agencias'))
    ```
   
   E existe alguma cidade que tenha agência pública, mas não privada? Quantas?
   
    ```{r}
    cidades %>% 
      filter(
        agencias_priv == 0 & agencias_publ > 0
      ) %>% 
      select(cidade, estado, starts_with('agencias'))
    ```

   :::

1. Comente os resultados.


## Agências bancárias (privadas) *per capita*

1. Faça um histograma da razão [(número de agências bancárias privadas) / (população)]{.hl}. Use o número de classes que você achar mais adequado.

   ::: {.rmdbox latex=1}
   
   Existem muitas cidades com zero agências privadas:
   
    ```{r}
    cidades %>% 
      count(agencias_priv)
    ```
   
   Vamos ignorá-las.
   
    ```{r ref.label='privadas-per-capita'}
    ```
   
   :::

1. Compare com a distribuição de agências públicas.

   ::: {.rmdbox latex=1}
   
    ```{r}
    privadaspc + publicaspc
    ```

   Para quase todos os valores de agências *per capita*, existem mais cidades com agências públicas do que cidades com agências privadas. 
   
   Isto é consequência de que, no total, [existem mais cidades atendidas por bancos públicos do que por bancos privados](#ag%C3%AAncias-banc%C3%A1rias-p%C3%BAblicas).
   
   Mas eu devia ter pedido um *scatterplot* de agências por população para um *insight* interessante.
   
   Aqui, descartamos as cidades com mais de $3$ milhões de habitantes.
   
    ```{r}
    cidades %>% 
      filter(
        agencias_priv > 0,
        agencias_publ > 0,
        pop_resid < 3e6
      ) %>% 
      ggplot() +
        geom_point(
          aes(
            x = pop_resid, 
            y = agencias_publ, 
            color = 'publ'
          ),
          alpha = .4
        ) +
        geom_smooth(
          aes(
            x = pop_resid, 
            y = agencias_publ, 
            color = 'publ'
          ),
          method = 'lm',
          se = FALSE
        ) +
        geom_point(
          aes(
            x = pop_resid, 
            y = agencias_priv, 
            color = 'priv'
          ),
          alpha = .2
        ) +
        geom_smooth(
          aes(
            x = pop_resid, 
            y = agencias_priv, 
            color = 'priv'
          ),
          method = 'lm',
          se = FALSE
        ) +
        scale_color_discrete(
          type = c('blue', 'red')
        ) +
        scale_x_continuous(
          breaks = seq(0, 3e6, .5e6),
          labels = scales::label_number(
            scale = 1e-6,
            suffix = 'M'
          )
        ) +
        labs(
          title = 'Agências bancárias por população',
          x = 'população',
          y = 'agências',
          color = NULL
        )
    ```
   
   As retas mostram como o número de agências aumenta à medida que a população aumenta.
   
   Para os bancos privados, o aumento é mais rápido.
   
   Em outras palavras: [para uma mesma população]{.hl}, existem, em média, [mais agências privadas do que públicas]{.hl}, e, quanto maior a população, maior a diferença.

   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   Comentários incluídos nas respostas acima.
   
   :::


## Áreas

1. Faça um histograma das áreas das cidades. Use o número de classes que você achar mais adequado.

   ::: {.rmdbox latex=1}
   
   Primeira tentativa:
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_histogram(
          aes(area),
          bins = 100
        ) +
        labs(
          y = NULL,
          x = 'Área (km²)'
        )
    ```
   
   Existem muitas cidades com área pequena, e poucos com área grande. Uma boa chance de usar uma escala logarítmica:
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_histogram(
          aes(area),
          bins = 50
        ) +
        scale_x_log10() +
        labs(
          title = 'Áreas (escala logarítmica)',
          y = NULL,
          x = 'Área (km²)'
        )
    ```   
   
   Podemos examinar apenas as cidades com área entre $0$ e $1000$ km² (com escala linear):
   
    ```{r}
    cidades %>% 
      filter(between(area, 0, 1000)) %>% 
      ggplot() +
        geom_histogram(
          aes(area),
          breaks = seq(0, 1000, 100)
        ) +
        scale_x_continuous(
          breaks = seq(0, 1000, 100)
        ) +
        labs(
          title = 'Área (até 1000km²)',
          y = NULL,
          x = 'Área (km²)'
        )
    ```      

   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   Alguns comentários incluídos nas respostas acima.
   
   A classe modal é entre $100$ e $200$ km².
   
   :::


## Áreas (com facetas)

1. Faça histogramas das áreas das cidades, [facetados por região geográfica]{.hl}. Use o número de classes que você achar mais adequado. Você vai precisar da resposta [desta questão](#regioes-geo).

1. Comente os resultados.


## Populações

1. Faça um histograma das populações das cidades. Use o número de classes que você achar mais adequado.

   ::: {.rmdbox latex=1}
   
   Primeira tentativa:
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_histogram(
          aes(x = pop_resid)
        )
    ```
   
   Usando escala logarítmica:
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_histogram(
          aes(x = pop_resid)
        ) +
        scale_x_log10(
          labels = scales::number_format(
            scale = 1e-3,
            suffix = 'k'
          )
        ) +
        labs(
          title = 'Populações',
          y = NULL,
          x = 'população'
        )
    ```

   Vamos limitar a cidades de no máximo $100$ mil habitantes, com escala linear:

    ```{r}
    cidades %>% 
      filter(pop_resid < 1e5) %>% 
      ggplot() +
        geom_histogram(
          aes(x = pop_resid),
          breaks = seq(0, 1e5, 10000)
        ) +
        scale_x_continuous(
          breaks = seq(0, 1e5, 10000),
          labels = scales::number_format(
            scale = 1e-3,
            suffix = 'k'
          )
        ) +
        labs(
          title = 'Populações (até 100 mil)',
          y = NULL,
          x = 'população'
        )
    ```
   
   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   Há muito mais cidades com poucos habitantes.
   
   A classe modal é a de cidades com até $10$ mil habitantes.
   
   A população mediana é
   
    ```{r}
    cidades$pop_resid %>% median()
    ```
   
   o que diz que aproximadamente metade das cidades tem menos de $11$ mil habitantes.
   
   Qual a população total destas cidades pequenas?
   
    ```{r}
    cidades %>% 
      mutate(
        tamanho = case_when(
          pop_resid < 11000 ~ 'Pequenas',
          TRUE ~ 'Grandes'
        )
      ) %>% 
      group_by(tamanho) %>% 
      summarize(populacao = sum(pop_resid))
    ```
   
   Embora metade das cidades tenha $11$ mil habitantes ou menos, sua população total é [$10$ vezes menor]{.hl} que a população total da outra metade.
   
   :::


## Populações (com facetas)

1. Faça histogramas das populações das cidades, [facetados por região geográfica]{.hl}. Use o número de classes que você achar mais adequado. Você vai precisar da resposta [desta questão](#regioes-geo).

1. Comente os resultados.


## PIB

1. Faça um histograma do valor do PIB. Use o número de classes que você achar mais adequado.

1. Comente os resultados.


## PIB *per capita*

1. Faça um histograma do valor do PIB *per capita*. Use o número de classes que você achar mais adequado.

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_histogram(
          aes(x = pib_capita)
        ) +
        labs(
          y = NULL,
          x = 'PIB per capita (R$)'
        ) +
        scale_x_continuous(
          labels = scales::number_format(
            scale = 1e-3,
            suffix = 'k'
          )
        )
    ```
   
   Em escala logarítmica:
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_histogram(
          aes(x = pib_capita)
        ) +
        labs(
          title = 'PIB per capita (escala logarítmica)',
          y = NULL,
          x = 'PIB per capita (R$)'
        ) +
        scale_x_log10(
          labels = scales::number_format(
            scale = 1e-3,
            suffix = 'k'
          )
        )
    ```

   Restringindo a um valor máximo:
   
    ```{r}
    cidades %>% 
      filter(pib_capita < 1e5) %>% 
      ggplot() +
        geom_histogram(
          aes(x = pib_capita),
          breaks = seq(0, 1e5, 1e4)
        ) +
        labs(
          title = 'PIB per capita (até 100 mil)',
          y = NULL,
          x = 'PIB per capita (R$)'
        ) +
        scale_x_continuous(
          breaks = seq(0, 1e5, 1e4),
          labels = scales::number_format(
            scale = 1e-3,
            suffix = 'k'
          )
        )
    ```
   
   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}

   É uma distribuição assimétrica, com uma longa cauda à direita.   

   A classe modal é entre $10$ e $20$ mil reais.
   
   :::
   

## Telefones fixos *per capita* (com facetas)

1. Faça histogramas das quantidades de telefones fixos *per capita*, [facetados por região geográfica]{.hl}. Use o número de classes que você achar mais adequado. Você vai precisar da resposta [desta questão](#regioes-geo).

1. Comente os resultados.


## Assinaturas de TV *per capita* (com facetas)

1. Faça histogramas das quantidades de assinaturas de TV por assinatura *per capita*, [facetados por região geográfica]{.hl}. Use o número de classes que você achar mais adequado. Você vai precisar da resposta [desta questão](#regioes-geo).

1. Comente os resultados.


## PIB e atividade principal

1. Faça *boxplots* lado a lado [(no mesmo gráfico, sem facetar)]{.hl} do PIB, com um *boxplot* para cada atividade principal. Faça com que os *boxplots* sejam horizontais, para facilitar a leitura dos nomes das atividades.

1. Comente os resultados.


## PIB *per capita* e atividade principal

1. Faça *boxplots* lado a lado [(no mesmo gráfico, sem facetar)]{.hl} do PIB *per capita*, com um *boxplot* para cada atividade principal. Faça com que os *boxplots* sejam horizontais, para facilitar a leitura dos nomes das atividades.

   ::: {.rmdbox latex=1}
   
   Primeira tentativa:
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_boxplot(
          aes(x = atividade_principal, y = pib_capita)
        ) +
      coord_flip()
    ```
   
   Vamos abreviar os nomes das atividades:
   
    ```{r}
    cidades %>% 
      mutate(
        atividade_principal = word(atividade_principal, end = 5)
      ) %>% 
      ggplot() +
        geom_boxplot(
          aes(x = atividade_principal, y = pib_capita)
        ) +
        labs(
          title = 'PIB per capita por atividade principal',
          y = 'PIB per capita',
          x = NULL
        ) +
        coord_flip()
    ```

   Podemos usar uma escala logarítmica:
   
    ```{r}
    cidades %>% 
      mutate(
        atividade_principal = word(atividade_principal, end = 5)
      ) %>% 
      ggplot() +
        geom_boxplot(
          aes(x = atividade_principal, y = pib_capita)
        ) +
        scale_y_log10() +
        labs(
          title = 'PIB per capita por atividade principal',
          subtitle = '(escala logarítmica)',
          y = 'PIB per capita',
          x = NULL
        ) +
        coord_flip()
    ```
   
   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   As atividades associadas ao [maior]{.hl} PIB *per capita* [mediano]{.hl} são (1) eletricidade, gás, água e esgoto e (2) comércio e reparação de veículos.
   
   As atividades associadas ao [menor]{.hl} PIB *per capita* [mediano]{.hl} são administração, defesa, educação e saúde.
   
   :::


## Hotéis e categoria de turismo

1. Faça *boxplots* lado a lado [(no mesmo gráfico, sem facetar)]{.hl} da quantidade de hotéis, com um *boxplot* para cada categoria de turismo. 

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_boxplot(
          aes(x = fct_rev(categoria_turismo), y = hoteis)
        ) +
        labs(
          title = 'Quantidade de hotéis por categoria de turismo',
          x = 'categoria de turismo'
        )
    ```

   :::
   
1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   Como era de se esperar, a quantidade de hotéis é muito maior em cidades da categoria A.
   
   :::

   
## Populações por região

1. Faça *boxplots* lado a lado [(no mesmo gráfico, sem facetar)]{.hl} das populações, com um *boxplot* para cada região geográfica. Você vai precisar da resposta [desta questão](#regioes-geo).

1. Comente os resultados.


## Densidade demográfica por região

1. Faça *boxplots* lado a lado [(no mesmo gráfico, sem facetar)]{.hl} das densidades demográficas, com um *boxplot* para cada região geográfica. Você vai precisar da resposta [desta questão](#regioes-geo).

1. Comente os resultados.


## Carros *per capita* por tipo de cidade

1. Faça *boxplots* lado a lado [(no mesmo gráfico, sem facetar)]{.hl} da quantidade de carros *per capita*, com um *boxplot* para cada tipo de cidade. 

1. Comente os resultados.


## Motos *per capita* por tipo de cidade

1. Faça *boxplots* lado a lado [(no mesmo gráfico, sem facetar)]{.hl} da quantidade de motos *per capita*, com um *boxplot* para cada tipo de cidade. 

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      filter(pop_resid > 0) %>% 
      mutate(mpc = motos / pop_resid) %>% 
      ggplot() +
        geom_boxplot(aes(x = tipo, y = mpc)) +
        scale_x_discrete(
          labels = function(x) {
            str_split(x, ' ') %>% 
              map_chr(paste, collapse = '\n')
          }
        ) +
        labs(
          title = 'Motos per capita por tipo de cidade',
          x = 'tipo de cidade',
          y = 'motos\nper capita'
        )
    ```
   
   :::
   
1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   Medianas semelhantes.
   
   Sem *outliers* em cidades do tipo intermediário remoto --- que, ironicamente, têm a maior variabilidade (em termos do IQR).
   
   :::
   

## Tratores *per capita* por tipo de cidade

1. Faça *boxplots* lado a lado [(no mesmo gráfico, sem facetar)]{.hl} da quantidade de tratores *per capita*, com um *boxplot* para cada tipo de cidade. 

1. Comente os resultados.


## Hotéis e Uber

1. Faça *boxplots* lado a lado [(no mesmo gráfico, sem facetar)]{.hl} da quantidade de hotéis, com um *boxplot* para cada valor de `uber`. 

1. Comente os resultados.


## PIB *per capita* e Uber

1. Faça *boxplots* lado a lado [(no mesmo gráfico, sem facetar)]{.hl} do valor do PIB *per capita*, com um *boxplot* para cada valor de `uber`. 

1. Comente os resultados.


## Cidades por região geográfica

1. Faça um gráfico de barras das quantidades de cidades, com uma barra por região. Você vai precisar da resposta [desta questão](#regioes-geo).

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_bar(
          aes(x = regiao)
        ) +
        labs(
          title = 'Quantidade de cidades por região geográfica',
          y = NULL
        )
    ```
   
   :::

1. Use a função `fct_reorder` para dispor as barras em ordem [decrescente]{.hl} de altura. 

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_bar(
          aes(
            x = fct_reorder(
              regiao, 
              cidade, 
              .fun = length, 
              .desc = TRUE
            )
          )
        ) +
        labs(
          title = 'Quantidade de cidades por região geográfica',
          y = NULL,
          x = 'região'
        )
    ```
   
   :::

1. Em outro gráfico, use a função `fct_reorder` para dispor as barras em ordem [crescente]{.hl} de altura. 

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_bar(
          aes(
            x = fct_reorder(
              regiao, 
              cidade, 
              .fun = length
            )
          )
        ) +
        labs(
          title = 'Quantidade de cidades por região geográfica',
          y = NULL,
          x = 'região'
        )
    ```
   
   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   Quais são as áreas totais das regiões?
   
    ```{r}
    cidades %>% 
      group_by(regiao) %>% 
      summarize(area = sum(area)) %>% 
      arrange(area)
    ```
   
   A região Norte tem a maior área, mas o menor número de cidades.
   
   A região Centro-Oeste tem a segunda maior área, mas o segundo menor número de cidades.
   
   As outras regiões seguem a mesma ordem, tanto em área quanto em número de cidades.
   
   :::


## Populações por região geográfica

1. Faça um gráfico de barras das populações totais, com uma barra por região. Você vai precisar da resposta [desta questão](#regioes-geo).

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_col(
          aes(x = regiao, y = pop_resid)
        ) +
        scale_y_continuous(
          labels = scales::number_format(
            scale = 1e-6,
            suffix = 'M'
          )
        ) +
        labs(
          title = 'População total por região geográfica',
          x = 'região',
          y = 'população'
        )
    ```
   
   :::

1. Use a função `fct_reorder` para dispor as barras em ordem [decrescente]{.hl} de altura. 

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_col(
          aes(
            x = fct_reorder(
              regiao,
              pop_resid,
              sum,
              .desc = TRUE
            ), 
            y = pop_resid
          )
        ) +
        scale_y_continuous(
          labels = scales::number_format(
            scale = 1e-6,
            suffix = 'M'
          )
        ) +
        labs(
          title = 'População total por região geográfica',
          x = 'região',
          y = 'população'
        )
    ```
   
   :::

1. Em outro gráfico, use a função `fct_reorder` para dispor as barras em ordem [crescente]{.hl} de altura. []{#pop-por-regiao}

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_col(
          aes(
            x = fct_reorder(
              regiao,
              pop_resid,
              sum
            ), 
            y = pop_resid
          )
        ) +
        scale_y_continuous(
          labels = scales::number_format(
            scale = 1e-6,
            suffix = 'M'
          )
        ) +
        labs(
          title = 'População total por região geográfica',
          x = 'região',
          y = 'população'
        )
    ```
   
   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   A região Sudeste é, de longe, a mais populosa, seguida da região Nordeste.
   
   A região Centro-Oeste é (um pouco) menos populosa do que a região Norte, ao contrário do que eu esperava.

   É interessante comparar com o [gráfico dos PIBs totais por região](#pib-por-regiao) e constatar que, com exceção do primeiro lugar, toda a ordenação muda.
   
   :::
   

## PIB por região geográfica

1. Faça um gráfico de barras dos PIBs totais, com uma barra por região. Você vai precisar da resposta [desta questão](#regioes-geo).

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_col(
          aes(x = regiao, y = pib)
        ) +
        scale_y_continuous(
          labels = scales::number_format(
            scale = 1e-9,
            suffix = 'B'
          )
        ) +
        labs(
          title = 'PIB por região geográfica',
          x = 'região',
          y = 'PIB'
        )
    ```
   
   :::

1. Use a função `fct_reorder` para dispor as barras em ordem [decrescente]{.hl} de altura. 

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_col(
          aes(
            x = fct_reorder(
              regiao,
              pib,
              sum,
              .desc = TRUE
            ), 
            y = pib
          )
        ) +
        scale_y_continuous(
          labels = scales::number_format(
            scale = 1e-9,
            suffix = 'B'
          )
        ) +
        labs(
          title = 'PIB por região geográfica',
          x = 'região',
          y = 'PIB'
        )
    ```
   
   :::

1. Em outro gráfico, use a função `fct_reorder` para dispor as barras em ordem [crescente]{.hl} de altura. []{#pib-por-regiao} 

   ::: {.rmdbox latex=1}
   
    ```{r}
    cidades %>% 
      ggplot() +
        geom_col(
          aes(
            x = fct_reorder(
              regiao,
              pib,
              sum
            ), 
            y = pib
          )
        ) +
        scale_y_continuous(
          labels = scales::number_format(
            scale = 1e-9,
            suffix = 'B'
          )
        ) +
        labs(
          title = 'PIB por região geográfica',
          x = 'região',
          y = 'PIB'
        )
    ```
   
   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   A ordenação é óbvia.
   
   É interessante comparar com o [gráfico das populações totais por região](#pop-por-regiao) e constatar que, com exceção do primeiro lugar, toda a ordenação muda.
   
   :::
   

## Produção rural por região geográfica

1. Faça um gráfico de barras das produções rurais totais, com uma barra por região. Você vai precisar da resposta [desta questão](#regioes-geo).

1. Use a função `fct_reorder` para dispor as barras em ordem [decrescente]{.hl} de altura. 

1. Em outro gráfico, use a função `fct_reorder` para dispor as barras em ordem [crescente]{.hl} de altura. 

1. Comente os resultados.


## Faixas etárias

1. Faça um gráfico de barras da população brasileira, com uma barra por faixa etária.

1. Use a função `fct_reorder` para dispor as barras em ordem [decrescente]{.hl} de altura. 

1. Em outro gráfico, use a função `fct_reorder` para dispor as barras em ordem [crescente]{.hl} de altura.

1. Em qual ordem você acha que as barras devem aparecer? Por quê?

1. Comente os resultados.


## Faixas etárias por região geográfica

1. Faça um gráfico de barras da população brasileira, com um [conjunto de barras para cada região]{.hl}. Você vai precisar da resposta [desta questão](#regioes-geo).

   ::: {.rmdbox latex=1}
   
   Veja abaixo.
   
   :::

1. Cada conjunto deve ter $6$ barras lado a lado, uma para cada faixa etária. Use o argumento `dodge` na geometria adequada.

   ::: {.rmdbox latex=1}
   
    ```{r}
    df_faixas <- cidades %>% 
      pivot_longer(
        cols = starts_with('pop_regular_'),
        names_to = 'faixa',
        names_prefix = 'pop_regular_',
        values_to = 'pop'
      ) %>% 
      mutate(
        faixa = case_when(
          faixa == '1' ~ 'até 1',
          faixa == '1_4' ~ '1 a 4',
          faixa == '5_9' ~ '5 a 9',
          faixa == '10_14' ~ '10 a 14',
          faixa == '15_59' ~ '15 a 59',
          faixa == '60_mais' ~ '60 ou mais'
        )
      ) %>% 
      mutate(
        faixa = factor(
          faixa,
          levels = unique(faixa),
          ordered = TRUE
        )
      ) %>% 
      select(cidade, regiao, faixa, pop)
    
    df_faixas
    ```
   
    ```{r}
    df_faixas %>% 
      ggplot() +
        geom_col(
          aes(x = regiao, y = pop, fill = faixa),
          position = 'dodge'
        ) +
        labs(
          title = 'População por região, por faixa etária',
          x = 'região',
          y = NULL,
          fill = NULL
        ) +
        scale_y_continuous(
          labels = scales::label_number(
            scale = 1e-6,
            suffix = 'M'
          )
        )
    ```
   
   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   Perceba que as faixas etárias têm larguras diferentes. 
   
   As únicas comparações razoáveis são entre [$1$ a $4$]{.hl}, [$5$ a $9$]{.hl}, e [$10$ a $14$]{.hl}, que têm larguras aproximadamente iguais.
   
   Em todas as regiões, há mais pessoas da faixa $10$ a $14$ do que das faixas mais jovens.
   
   As regiões Centro-Oeste e Norte são as únicas onde há menos idosos do que jovens de $10$ a $14$.
   
   :::


## Faixas etárias por região geográfica, proporções

1. Faça um gráfico de barras da população brasileira, com uma barra por região. Você vai precisar da resposta [desta questão](#regioes-geo).

   ::: {.rmdbox latex=1}
   
   Veja abaixo.
   
   :::

1. Todas as barras devem ser da mesma altura, e o eixo $y$ deve ir de $0$ até $1$, representando proporções.

   ::: {.rmdbox latex=1}
   
   Veja abaixo.
   
   :::

1. Cada barra deve ser subdividida em faixas horizontais de cores diferentes, uma faixa colorida para cada faixa etária, de acordo com as proporções de cada faixa etária em cada região.

   ::: {.rmdbox latex=1}
   
    ```{r}
    df_faixas <- cidades %>% 
      pivot_longer(
        cols = starts_with('pop_regular_'),
        names_to = 'faixa',
        names_prefix = 'pop_regular_',
        values_to = 'pop'
      ) %>% 
      mutate(
        faixa = case_when(
          faixa == '1' ~ 'até 1',
          faixa == '1_4' ~ '1 a 4',
          faixa == '5_9' ~ '5 a 9',
          faixa == '10_14' ~ '10 a 14',
          faixa == '15_59' ~ '15 a 59',
          faixa == '60_mais' ~ '60 ou mais'
        )
      ) %>% 
      mutate(
        faixa = factor(
          faixa,
          levels = unique(faixa),
          ordered = TRUE
        )
      ) %>% 
      select(cidade, regiao, faixa, pop)
    
    df_faixas
    ```
   
    ```{r}
    df_faixas %>% 
      ggplot() +
        geom_col(
          aes(x = regiao, y = pop, fill = fct_rev(faixa)),
          position = 'fill'
        ) +
        labs(
          title = 'População por região, por faixa etária',
          subtitle = '(proporções)',
          x = 'região',
          y = NULL,
          fill = NULL
        )
    ```
   
   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   As proporções são semelhantes entre as regiões.
   
   A região Norte tem a menor proporção de idosos, e a maior proporção de pessoas até $14$ anos.
   
   As regiões Sul e Sudeste têm a maior proporção de idosos.
   
   :::


## Faixas etárias por tipo de cidade

1. Faça um gráfico de barras da população brasileira, com um [conjunto de barras para cada tipo de cidade]{.hl}.

   ::: {.rmdbox latex=1}
   
   Veja abaixo.
   
   :::

1. Cada conjunto deve ter $6$ barras lado a lado, uma para cada faixa etária. Use o argumento `dodge` na geometria adequada.

   ::: {.rmdbox latex=1}
   
    ```{r}
    df_faixas <- cidades %>% 
      pivot_longer(
        cols = starts_with('pop_regular_'),
        names_to = 'faixa',
        names_prefix = 'pop_regular_',
        values_to = 'pop'
      ) %>% 
      mutate(
        faixa = case_when(
          faixa == '1' ~ 'até 1',
          faixa == '1_4' ~ '1 a 4',
          faixa == '5_9' ~ '5 a 9',
          faixa == '10_14' ~ '10 a 14',
          faixa == '15_59' ~ '15 a 59',
          faixa == '60_mais' ~ '60 ou mais'
        )
      ) %>% 
      mutate(
        faixa = factor(
          faixa,
          levels = unique(faixa),
          ordered = TRUE
        )
      ) %>% 
      select(cidade, tipo, faixa, pop)
    
    df_faixas
    ```
   
    ```{r}
    df_faixas %>% 
      ggplot() +
        geom_col(
          aes(x = tipo, y = pop, fill = faixa),
          position = 'dodge'
        ) +
        labs(
          title = 'População por tipo de cidade, por faixa etária',
          x = 'tipo de cidade',
          y = NULL,
          fill = NULL
        )
    ```

   A população de cidades do tipo urbano é tão grande que os outros tipos ficam quase invisíveis.
   
   [Veja a próxima questão](#proporcoes), que resolve este problema mostrando as [proporções]{.hl} das diversas faixas etárias.
   
   Vamos excluir o tipo urbano do gráfico:
   
    ```{r}
    df_faixas %>% 
      filter(tipo != 'Urbano') %>% 
      ggplot() +
        geom_col(
          aes(x = tipo, y = pop, fill = faixa),
          position = 'dodge'
        ) +
        labs(
          title = 'População por tipo de cidade, por faixa etária',
          subtitle = 'exceto centros urbanos',
          x = 'tipo de cidade',
          y = NULL,
          fill = NULL
        )
    ```

   Vamos melhorar os rótulos do eixo $x$ e ignorar as cidades sem classificação:
   
    ```{r}
    df_faixas %>% 
      filter(tipo != 'Urbano') %>% 
      filter(tipo != 'Sem classificação') %>% 
      ggplot() +
        geom_col(
          aes(x = tipo, y = pop, fill = faixa),
          position = 'dodge'
        ) +
        labs(
          title = 'População por tipo de cidade, por faixa etária',
          subtitle = 'exceto centros urbanos',
          x = 'tipo de cidade',
          y = NULL,
          fill = NULL
        ) +
        scale_x_discrete(
          labels = function(x) {
            str_split(x, ' ') %>% 
              map_chr(paste, collapse = '\n')
          }
        )
    ```

   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   Os centros urbanos têm uma população muito maior do que os outros tipos de cidade.
   
   Cidades do tipo urbano e intermediário adjacente parecem ter uma proporção significativamente maior de pessoas entre $15$ a $59$ anos.
   
   :::
   

## Faixas etárias por tipo de cidade, proporções { #proporcoes }

1. Faça um gráfico de barras da população brasileira, com uma barra por tipo de cidade.

   ::: {.rmdbox latex=1}
   
   Veja abaixo.
   
   :::

1. Todas as barras devem ser da mesma altura, e o eixo $y$ deve ir de $0$ até $1$, representando proporções.

   ::: {.rmdbox latex=1}
   
   Veja abaixo.
   
   :::

1. Cada barra deve ser subdividida em faixas horizontais de cores diferentes, uma faixa colorida para cada faixa etária, de acordo com as proporções de cada faixa etária em cada tipo de cidade.

   ::: {.rmdbox latex=1}
   
    ```{r}
    df_faixas <- cidades %>% 
      pivot_longer(
        cols = starts_with('pop_regular_'),
        names_to = 'faixa',
        names_prefix = 'pop_regular_',
        values_to = 'pop'
      ) %>% 
      mutate(
        faixa = case_when(
          faixa == '1' ~ 'até 1',
          faixa == '1_4' ~ '1 a 4',
          faixa == '5_9' ~ '5 a 9',
          faixa == '10_14' ~ '10 a 14',
          faixa == '15_59' ~ '15 a 59',
          faixa == '60_mais' ~ '60 ou mais'
        )
      ) %>% 
      mutate(
        faixa = factor(
          faixa,
          levels = unique(faixa),
          ordered = TRUE
        )
      ) %>% 
      select(cidade, tipo, faixa, pop)
    
    df_faixas
    ```
   
    ```{r}
    df_faixas %>% 
      ggplot() +
        geom_col(
          aes(x = tipo, y = pop, fill = fct_rev(faixa)),
          position = 'fill'
        ) +
        labs(
          title = 'População por tipo de cidade, por faixa etária',
          subtitle = '(proporções)',
          x = 'tipo de cidade',
          y = NULL,
          fill = NULL
        )
    ```
   
   Vamos melhorar os rótulos do eixo $x$ e ignorar as cidades sem classificação:
   
    ```{r}
    df_faixas %>% 
      filter(tipo != 'Sem classificação') %>% 
      ggplot() +
        geom_col(
          aes(x = tipo, y = pop, fill = fct_rev(faixa)),
          position = 'fill'
        ) +
        labs(
          title = 'População por tipo de cidade, por faixa etária',
          subtitle = '(proporções)',
          x = 'tipo de cidade',
          y = NULL,
          fill = NULL
        ) +
        scale_x_discrete(
          labels = function(x) {
            str_split(x, ' ') %>% 
              map_chr(paste, collapse = '\n')
          }
        )
    ```

   :::

1. Comente os resultados.

   ::: {.rmdbox latex=1}
   
   Proporcionalmente. há mais idosos em cidades de tipos urbano, intermediário adjacente e rural adjacente.
   
   Proporcionalmente. há mais jovens em cidades de tipos intermediário remoto e rural remoto.
   
   :::
   

# Mapa interativo

## Marcadores

1. Leia algum tutorial sobre o pacote `leaflet`:

   * Em inglês: https://rstudio.github.io/leaflet/ (basta ler os $5$ primeiros itens do menu).
   
   * Em português: http://sillasgonzaga.com/material/cdr/htmlwidgets.html#leaflet (até "Marcadores").
     
1. Escolha qualquer uma das questões do tipo "Quais as $10$ cidades...", na [seção de análise exploratória](#eda).

1. Resolva a questão e modifique o código abaixo para criar marcadores mostrando as cidades da resposta, [rotulados com os nomes das cidades]{.hl} (use o argumento `label`).

1. Quando o usuário clicar o *mouse* sobre a cidade, deve aparecer a informação relevante pedida pela questão (use o argumento `popup`).

1. Acrescente outras informações que você achar importantes --- por exemplo, a classificação da cidade na ordenação que a questão pede.

    ```{r}
    library(leaflet)
    
    # Um exemplo, apenas. Substitua com a tibble da sua resposta:
    df <- cidades %>% 
      filter(
        cidade %in% c('Manaus', 'Brasília', 'Porto Alegre')
      )
    
    # O mapa:
    leaflet(df) %>% 
      setView(
        lng = mean(df$longitude), 
        lat = mean(df$latitude),
        zoom = 4
      ) %>% 
      addTiles() %>% 
      addMarkers()
    ```

1. Faça [um segundo mapa interativo]{.hl} com marcadores para as cidades que satisfazem algum critério que você ache interessante. Use a imaginação.

